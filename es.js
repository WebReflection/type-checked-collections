const e=()=>!0,t=e=>{throw new TypeError(e)},n=(t,n)=>{const s=[];if(t)for(const e of t.split(/\s*\|\s*/))"object"===e?s.push((t=>null!==t&&typeof t===e)):"null"===e?s.push((e=>null===e)):s.push((t=>typeof t===e));if(n)for(const e of[].concat(n))s.push((t=>t instanceof e));switch(s.length){case 0:return e;case 1:return s[0];default:return e=>s.some((t=>t(e)))}},s=(e,n,s,o=t)=>t=>{const r=[`Invalid ${typeof t} ${s}: expected `];e&&(r.push(e),n&&r.push(" or ")),n&&(r.push("an instanceof "),r.push([].concat(n).map((({name:e})=>e)).join(" | "))),o(r.join(""),t)},o=(e,t="value")=>{const o=e?.typeof,r=e?.instanceof;return[n(o,r),s(o,r,t,e?.onerror)]},r=e=>t=>{const[n,s]=o(t);return class extends e{add(e){return n(e)?super.add(e):s(e)}}},u=r(Set),c=r(WeakSet),a=e=>([t,n])=>{const[s,r]=o(t,"key"),[u,c]=o(n);return class extends e{set(e,t){return s(e)||r(e),u(t)||c(t),super.set(e,t)}}},p=a(Map),f=a(WeakMap);export{p as typedMap,u as typedSet,f as typedWeakMap,c as typedWeakSet};
